virtus\EasySerial.cpp-------------------------------------------------
#include "EasySerial.h"

EasySerial es;

EasySerial::EasySerial(uint32_t baud_rate) : baud_rate_(baud_rate) {
    begin();
}

void EasySerial::begin() {
    Serial.begin(baud_rate_);
    while (!Serial) {
        ; // Wait for Serial to initialize (optional, useful for some boards)
    }
}

void EasySerial::printTimestamp() {
    unsigned long ms = millis();
    Serial.print("[");
    Serial.print(ms / 1000); // Seconds
    Serial.print(".");
    if (ms % 1000 < 100) Serial.print("0");
    if (ms % 1000 < 10) Serial.print("0");
    Serial.print(ms % 1000); // Milliseconds
    Serial.print("] ");
}

void EasySerial::print(const char* message) {
    printTimestamp();
    Serial.print(message);
}

void EasySerial::print(const String& message) {
    printTimestamp();
    Serial.print(message);
}

void EasySerial::print(int value) {
    printTimestamp();
    Serial.print(value);
}

void EasySerial::print(unsigned long value) {
    printTimestamp();
    Serial.print(value);
}

void EasySerial::println(const char* message) {
    printTimestamp();
    Serial.println(message);
}

void EasySerial::println(const String& message) {
    printTimestamp();
    Serial.println(message);
}

void EasySerial::println(int value) {
    printTimestamp();
    Serial.println(value);
}

void EasySerial::println(unsigned long value) {
    printTimestamp();
    Serial.println(value);
}


virtus\EasySerial.h-------------------------------------------------
#ifndef SERIAL_DEBUGGER_H
#define SERIAL_DEBUGGER_H

#include <Arduino.h>

class EasySerial {
public:
    // Constructor: Initialize with a baud rate
    EasySerial(uint32_t baud_rate = 115200);

    // Initialize the Serial port
    void begin();

    // Print with timestamp (no newline)
    void print(const char* message);
    void print(const String& message);
    void print(int value);
    void print(unsigned long value);

    // Print with timestamp and newline
    void println(const char* message);
    void println(const String& message);
    void println(int value);
    void println(unsigned long value);

private:
    uint32_t baud_rate_; // Baud rate for Serial communication
    void printTimestamp(); // Helper to print the timestamp
};

extern EasySerial es;

#endif // SERIAL_DEBUGGER_H

virtus\System.cpp-------------------------------------------------
#include "System.h"

// State Flags
static bool basic_boot_complete;
RTC_DATA_ATTR bool first_time_boot_complete; // zero-initialized on battery drain or restart
static bool force_complete_first_time_boot;
static bool os_init_complete;
static bool inactive;


void System::resolve() {
    es.println("entered resolve");
    while (true) {
        if (!basic_boot_complete) {
            basic_boot();
        } else if (!first_time_boot_complete && !force_complete_first_time_boot) {
            es.println("beginning first_time_boot stage");
            first_time_boot();
        } else if (!os_init_complete) {
            es.println("beginning os_init stage");
            os_init();
        } else {
            es.println("beginning active-Loop stage");
            active_loop();
        }
    }
}

void System::basic_boot() {
    es.println("starting...");
    btStop();
    setCpuFrequencyMhz(160);
    Serial.begin(115200);
    pinMode(BOARD_TOUCH_INT, INPUT);
    Wire.begin(BOARD_I2C_SDA, BOARD_I2C_SCL);
    Wire1.begin(BOARD_TOUCH_SDA, BOARD_TOUCH_SCL);

    battery.handle_basic_boot();
    screen.handle_basic_boot();
    screen_manager.handle_basic_boot(first_time_boot_complete);
    basic_boot_complete = true;
}

void System::first_time_boot() {
    bios_mailbox = new Mailbox<int>();
    bios.setup_system_comm(bios_mailbox);
    work_manager.add_app_job(0); // first-time boot UI

    while (true) {        
        screen_manager.step();
        delay(2);
        
        int bios_result = -1;
        if (bios_mailbox->read(bios_result, 0)) {
            es.println("READ bios result!");
            es.println(bios_result);
            if (bios_result == 0) {
                first_time_boot_complete = true;
                break;
            }
            else if (bios_result == 1) {
                force_complete_first_time_boot = true;
                break;
            } 
        }
    }

    delete bios_mailbox;

}

void System::os_init() {
    os_init_complete = true;
}

void System::active_loop() {
    work_manager.add_app_job(1); // watch face
    while (true) {        
        screen_manager.step();
        delay(2);
    }
}

virtus\System.h-------------------------------------------------
#ifndef SYSTEM_H
#define SYSTEM_H

#include <Arduino.h>

#include <FFat.h>
#include <FS.h>
#include <Wire.h>
#include <SensorDRV2605.hpp>
#include <driver/i2s.h>
#include <driver/temp_sensor.h>

#include "utilities.h"
#include "EasySerial.h"

#include "Drivers/Battery/Battery.h"
#include "Drivers/Screen/Screen.h"

#include "Services/ScreenManager/ScreenManager.h"
#include "Services/WorkManager/WorkManager.h"
#include "Services/TimeService/TimeService.h"
#include "Services/Mailbox/Mailbox.h"

#include "Apps/System/BIOS/BIOS.h"


#define LEDC_BACKLIGHT_CHANNEL      3
#define LEDC_BACKLIGHT_BIT_WIDTH    8
#define LEDC_BACKLIGHT_FREQ         1000

class System {
public:
    void resolve();

private:
    void basic_boot();
    void first_time_boot();
    void os_init();
    void active_loop();

    Mailbox<int>* bios_mailbox;
};

extern System sys;

#endif

virtus\utilities.h-------------------------------------------------
#pragma once

#define BOARD_TFT_WIDTH             (240)
#define BOARD_TFT_HEIGHT             (240)

// ST7789
#define BOARD_TFT_MISO              (-1)
#define BOARD_TFT_MOSI              (13)
#define BOARD_TFT_SCLK              (18)
#define BOARD_TFT_CS                (12)
#define BOARD_TFT_DC                (38)
#define BOARD_TFT_RST               (-1)
#define BOARD_TFT_BL                (45)

// Touch
#define BOARD_TOUCH_SDA             (39)
#define BOARD_TOUCH_SCL             (40)
#define BOARD_TOUCH_INT             (16)

//BMA423,PCF8563,AXP2101,DRV2605L
#define BOARD_I2C_SDA               (10)
#define BOARD_I2C_SCL               (11)

// PCF8563 Interrupt
#define BOARD_RTC_INT_PIN           (17)
// AXP2101 Interrupt
#define BOARD_PMU_INT               (21)
// BMA423 Interrupt
#define BOARD_BMA423_INT1           (14)

// MAX98357A
#define BOARD_DAC_IIS_BCK           (48)
#define BOARD_DAC_IIS_WS            (15)
#define BOARD_DAC_IIS_DOUT          (46)


virtus\virtus.ino-------------------------------------------------
#include "System.h"

System sys;

void setup()
{
    sys.resolve();
}

void loop(){

}

virtus\Apps\AppRegistry.h-------------------------------------------------
#ifndef APPREGISTRY_H
#define APPREGISTRY_H

#include "Apps/BaseApp.h"
#include "Apps/System/BIOS/BIOS.h"
#include "Apps/System/DefaultWatchFace/DefaultWatchFace.h"

inline BaseApp* app_registry[] = {
    &bios, &default_watch_face
};

#endif

virtus\Apps\BaseApp.h-------------------------------------------------
#ifndef BASEAPP_H
#define BASEAPP_H

#include <lvgl.h>

class BaseApp {
public:
    virtual ~BaseApp() {};

    virtual int mount(lv_obj_t* canvas);
    virtual int unmount();

    virtual void update_live_state() {};
};

#endif

virtus\Apps\System\BIOS\BIOS.cpp-------------------------------------------------
#include "Apps/System/BIOS/BIOS.h"
#include "Services/WorkManager/WorkManager.h"
#include "Services/TimeService/TimeService.h"

#include <lvgl.h>

BIOS bios;

Mailbox<int>* BIOS::system_mailbox = nullptr;

void BIOS::setup_system_comm(Mailbox<int>* mailbox){
    system_mailbox = mailbox;
}

void BIOS::ble_button_clicked(lv_event_t * e)
{
    bios.screen_state.selection = "BLE";
    bios.state_changed = true;
}

void BIOS::manual_button_clicked(lv_event_t * e)
{
    bios.screen_state.selection = "Manual";
    bios.state_changed = true;
}


void BIOS::ble_try_again_button_clicked(lv_event_t * e)
{
    work_manager.add_cpu_job([&]() {
        time_service.sync_via_bluetooth(30, bios.mail_time_service);
    });
    bios.screen_state.ble_busy = true;
    bios.state_changed = true;
}

void BIOS::continue_button_clicked(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if (bios.screen_state.error) {
        es.println("writing 1 to system mailbox in continue");
        system_mailbox->write(1);
    }
    else {
        es.println("writing 0 to system mailbox in continue");
        system_mailbox->write(0);
    }    
}

int BIOS::mount(lv_obj_t* canvas) {
    if (!canvas) {
        Serial.println("Error: BIOS::mount received null canvas");
        return -1;
    }

    mail_time_service = new Mailbox<int>();
    bios.state_changed = false;

    work_manager.add_cpu_job([&]() {
        time_service.sync_via_bluetooth(30, mail_time_service);
    });

    frame = lv_obj_create(canvas);
    lv_obj_remove_style_all(frame);
    lv_obj_set_width(frame, lv_pct(100));
    lv_obj_set_height(frame, lv_pct(100));
    lv_obj_set_pos(frame, 0, 0);
    lv_obj_set_align(frame, LV_ALIGN_TOP_LEFT);
    lv_obj_set_flex_flow(frame, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(frame, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
    lv_obj_clear_flag(frame, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_set_style_bg_color(frame, lv_color_hex(0x000000), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(frame, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    // Splash screen
    splash_container = lv_obj_create(frame);
    lv_obj_remove_style_all(splash_container);
    lv_obj_set_height(splash_container, lv_pct(100));
    lv_obj_set_width(splash_container, lv_pct(100));
    lv_obj_set_align(splash_container, LV_ALIGN_CENTER);

    splash_label = lv_label_create(splash_container);
    lv_obj_set_width(splash_label, LV_SIZE_CONTENT);
    lv_obj_set_height(splash_label, LV_SIZE_CONTENT);
    lv_obj_set_align(splash_label, LV_ALIGN_CENTER);
    lv_label_set_text(splash_label, "Starting...");
    lv_obj_set_style_text_color(splash_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(splash_label, &lv_font_montserrat_20, LV_PART_MAIN | LV_STATE_DEFAULT);

    // Form title
    form_title_container = lv_obj_create(frame);
    lv_obj_remove_style_all(form_title_container);
    lv_obj_set_height(form_title_container, 30);
    lv_obj_set_width(form_title_container, lv_pct(100));
    lv_obj_set_align(form_title_container, LV_ALIGN_CENTER);
    lv_obj_clear_flag(form_title_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    form_title_label = lv_label_create(form_title_container);
    lv_obj_set_width(form_title_label, LV_SIZE_CONTENT);
    lv_obj_set_height(form_title_label, LV_SIZE_CONTENT);
    lv_obj_set_align(form_title_label, LV_ALIGN_CENTER);
    lv_label_set_text(form_title_label, "Cold Boot Menu");
    lv_obj_clear_flag(form_title_label, LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM |
                      LV_OBJ_FLAG_SCROLL_CHAIN);
    lv_obj_set_style_text_font(form_title_label, &lv_font_montserrat_20, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(form_title_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Form subtitle
    form_subtitle_container = lv_obj_create(frame);
    lv_obj_remove_style_all(form_subtitle_container);
    lv_obj_set_height(form_subtitle_container, 30);
    lv_obj_set_width(form_subtitle_container, lv_pct(100));
    lv_obj_set_align(form_subtitle_container, LV_ALIGN_CENTER);
    lv_obj_clear_flag(form_subtitle_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    form_subtitle_label = lv_label_create(form_subtitle_container);
    lv_obj_set_width(form_subtitle_label, LV_SIZE_CONTENT);
    lv_obj_set_height(form_subtitle_label, LV_SIZE_CONTENT);
    lv_obj_set_align(form_subtitle_label, LV_ALIGN_CENTER);
    lv_label_set_text(form_subtitle_label, "Time Settings");
    lv_obj_set_style_text_color(form_subtitle_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Form error
    form_error_container = lv_obj_create(frame);
    lv_obj_remove_style_all(form_error_container);
    lv_obj_set_height(form_error_container, 30);
    lv_obj_set_width(form_error_container, lv_pct(100));
    lv_obj_set_align(form_error_container, LV_ALIGN_CENTER);
    lv_obj_clear_flag(form_error_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    form_error_label = lv_label_create(form_error_container);
    lv_obj_set_width(form_error_label, LV_SIZE_CONTENT);
    lv_obj_set_height(form_error_label, LV_SIZE_CONTENT);
    lv_obj_set_align(form_error_label, LV_ALIGN_CENTER);
    lv_label_set_text(form_error_label, "Automatic Sync failed.\nPlease explore options:");
    lv_obj_set_style_text_color(form_error_label, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(form_error_label, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    // BLE button
    form_button_ble_container = lv_obj_create(frame);
    lv_obj_remove_style_all(form_button_ble_container);
    lv_obj_set_height(form_button_ble_container, 50);
    lv_obj_set_width(form_button_ble_container, lv_pct(100));
    lv_obj_set_align(form_button_ble_container, LV_ALIGN_CENTER);
    lv_obj_clear_flag(form_button_ble_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    form_button_ble_button = lv_btn_create(form_button_ble_container);
    lv_obj_set_height(form_button_ble_button, 30);
    lv_obj_set_width(form_button_ble_button, lv_pct(70));
    lv_obj_set_align(form_button_ble_button, LV_ALIGN_CENTER);
    lv_obj_add_flag(form_button_ble_button, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
    lv_obj_clear_flag(form_button_ble_button, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_bg_color(form_button_ble_button, lv_color_hex(0x313131), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(form_button_ble_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    form_button_ble_button_label = lv_label_create(form_button_ble_button);
    lv_obj_set_width(form_button_ble_button_label, LV_SIZE_CONTENT);
    lv_obj_set_height(form_button_ble_button_label, LV_SIZE_CONTENT);
    lv_obj_set_align(form_button_ble_button_label, LV_ALIGN_CENTER);
    lv_label_set_text(form_button_ble_button_label, "Bluetooth Time Sync");
    lv_obj_set_style_text_color(form_button_ble_button_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Manual button
    form_button_manual_container = lv_obj_create(frame);
    lv_obj_remove_style_all(form_button_manual_container);
    lv_obj_set_height(form_button_manual_container, 50);
    lv_obj_set_width(form_button_manual_container, lv_pct(100));
    lv_obj_set_align(form_button_manual_container, LV_ALIGN_CENTER);
    lv_obj_clear_flag(form_button_manual_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    form_button_manual_button = lv_btn_create(form_button_manual_container);
    lv_obj_set_height(form_button_manual_button, 30);
    lv_obj_set_width(form_button_manual_button, lv_pct(70));
    lv_obj_set_align(form_button_manual_button, LV_ALIGN_CENTER);
    lv_obj_add_flag(form_button_manual_button, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
    lv_obj_clear_flag(form_button_manual_button, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_bg_color(form_button_manual_button, lv_color_hex(0x313131), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(form_button_manual_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    form_button_manual_label = lv_label_create(form_button_manual_button);
    lv_obj_set_width(form_button_manual_label, LV_SIZE_CONTENT);
    lv_obj_set_height(form_button_manual_label, LV_SIZE_CONTENT);
    lv_obj_set_align(form_button_manual_label, LV_ALIGN_CENTER);
    lv_label_set_text(form_button_manual_label, "Manual Setting");
    lv_obj_set_style_text_color(form_button_manual_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Form testing area container
    form_testing_area = lv_obj_create(frame);
    lv_obj_remove_style_all(form_testing_area);
    lv_obj_set_width(form_testing_area, lv_pct(100));
    lv_obj_set_height(form_testing_area, LV_SIZE_CONTENT);
    lv_obj_set_align(form_testing_area, LV_ALIGN_CENTER);
    lv_obj_set_flex_flow(form_testing_area, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(form_testing_area, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
    lv_obj_clear_flag(form_testing_area, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    // BLE testing area
    form_testing_area_ble = lv_obj_create(form_testing_area);
    lv_obj_remove_style_all(form_testing_area_ble);
    lv_obj_set_height(form_testing_area_ble, LV_SIZE_CONTENT);
    lv_obj_set_width(form_testing_area_ble, lv_pct(100));
    lv_obj_set_align(form_testing_area_ble, LV_ALIGN_CENTER);
    lv_obj_set_flex_flow(form_testing_area_ble, LV_FLEX_FLOW_COLUMN);
    lv_obj_clear_flag(form_testing_area_ble, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    ble_info_container = lv_obj_create(form_testing_area_ble);
    lv_obj_remove_style_all(ble_info_container);
    lv_obj_set_height(ble_info_container, 50);
    lv_obj_set_width(ble_info_container, lv_pct(100));
    lv_obj_set_align(ble_info_container, LV_ALIGN_CENTER);
    lv_obj_clear_flag(ble_info_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    ble_info_label = lv_label_create(ble_info_container);
    lv_obj_set_width(ble_info_label, LV_SIZE_CONTENT);
    lv_obj_set_height(ble_info_label, LV_SIZE_CONTENT);
    lv_obj_set_align(ble_info_label, LV_ALIGN_CENTER);
    lv_label_set_text(ble_info_label, "Please install the XYZ app on\nyour phone to to sync time.");
    lv_obj_set_style_text_color(ble_info_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);

    try_again_button_container = lv_obj_create(form_testing_area_ble);
    lv_obj_remove_style_all(try_again_button_container);
    lv_obj_set_height(try_again_button_container, 50);
    lv_obj_set_width(try_again_button_container, lv_pct(100));
    lv_obj_set_align(try_again_button_container, LV_ALIGN_CENTER);
    lv_obj_clear_flag(try_again_button_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    try_again_button_button = lv_btn_create(try_again_button_container);
    lv_obj_set_height(try_again_button_button, 30);
    lv_obj_set_width(try_again_button_button, lv_pct(70));
    lv_obj_set_align(try_again_button_button, LV_ALIGN_CENTER);
    lv_obj_add_flag(try_again_button_button, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
    lv_obj_clear_flag(try_again_button_button, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_bg_color(try_again_button_button, lv_color_hex(0x313131), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(try_again_button_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    try_again_button_label = lv_label_create(try_again_button_button);
    lv_obj_set_width(try_again_button_label, LV_SIZE_CONTENT);
    lv_obj_set_height(try_again_button_label, LV_SIZE_CONTENT);
    lv_obj_set_align(try_again_button_label, LV_ALIGN_CENTER);
    lv_label_set_text(try_again_button_label, "Try again...");
    lv_obj_set_style_text_color(try_again_button_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Manual testing area
    form_testing_area_manual = lv_obj_create(form_testing_area);
    lv_obj_remove_style_all(form_testing_area_manual);
    lv_obj_set_height(form_testing_area_manual, LV_SIZE_CONTENT);
    lv_obj_set_width(form_testing_area_manual, lv_pct(100));
    lv_obj_set_align(form_testing_area_manual, LV_ALIGN_CENTER);
    lv_obj_clear_flag(form_testing_area_manual, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    manual_info_label = lv_label_create(form_testing_area_manual);
    lv_obj_set_width(manual_info_label, LV_SIZE_CONTENT);
    lv_obj_set_height(manual_info_label, LV_SIZE_CONTENT);
    lv_obj_set_align(manual_info_label, LV_ALIGN_CENTER);
    lv_label_set_text(manual_info_label, "Manual not yet supported");
    lv_obj_set_style_text_color(manual_info_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Continue button
    continue_button_container = lv_obj_create(frame);
    lv_obj_remove_style_all(continue_button_container);
    lv_obj_set_height(continue_button_container, 50);
    lv_obj_set_width(continue_button_container, lv_pct(100));
    lv_obj_set_align(continue_button_container, LV_ALIGN_CENTER);
    lv_obj_clear_flag(continue_button_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);

    continue_button_button = lv_btn_create(continue_button_container);
    lv_obj_set_height(continue_button_button, 30);
    lv_obj_set_width(continue_button_button, lv_pct(90));
    lv_obj_set_align(continue_button_button, LV_ALIGN_CENTER);
    lv_obj_add_flag(continue_button_button, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
    lv_obj_clear_flag(continue_button_button, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_bg_color(continue_button_button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(continue_button_button, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    continue_button_label = lv_label_create(continue_button_button);
    lv_obj_set_width(continue_button_label, LV_SIZE_CONTENT);
    lv_obj_set_height(continue_button_label, LV_SIZE_CONTENT);
    lv_obj_set_align(continue_button_label, LV_ALIGN_CENTER);
    lv_label_set_text(continue_button_label, "Ignore error & continue");
    lv_obj_set_style_text_color(continue_button_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);



    lv_obj_add_event_cb(form_button_ble_button, ble_button_clicked, LV_EVENT_CLICKED, NULL);
    lv_obj_add_event_cb(form_button_manual_button, manual_button_clicked, LV_EVENT_CLICKED, NULL);
    lv_obj_add_event_cb(try_again_button_button, ble_try_again_button_clicked, LV_EVENT_CLICKED, NULL);
    lv_obj_add_event_cb(continue_button_button, continue_button_clicked, LV_EVENT_CLICKED, NULL);

    return 0;
}


void BIOS::update_live_state() {
    int x = -1;
    if (mail_time_service->read(x, 0)) {
        es.println("READ!");
        es.println(x);
        if (x == 0 && screen_state.splash) {
            es.println("read successful time sync! now writing to system mailbox");
            system_mailbox->write(0);
        }
        else if (x == 1 && screen_state.splash) {
            screen_state.splash = false;
            state_changed = true;
        }
        else if (x == 0 && !screen_state.splash) {
            screen_state.error = false;
            screen_state.ble_busy = false;
            state_changed = true;
        }
        else if (x == 1 && !screen_state.splash) {
            screen_state.ble_busy = false;
            state_changed = true;
        }
    }

    if (state_changed) {
        // Splash screen handling
        if (screen_state.splash) {
            lv_obj_add_flag(form_title_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(form_subtitle_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(form_error_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(form_button_ble_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(form_button_manual_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(form_testing_area, LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(continue_button_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(splash_container, LV_OBJ_FLAG_HIDDEN);
        } else {
            lv_obj_add_flag(splash_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(form_title_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(form_subtitle_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(form_button_ble_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(form_button_manual_container, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(form_testing_area, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(continue_button_container, LV_OBJ_FLAG_HIDDEN);

            // Error handling
            if (screen_state.error) {
                lv_obj_clear_flag(form_error_container, LV_OBJ_FLAG_HIDDEN);
                lv_obj_set_style_bg_color(continue_button_button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_label_set_text(continue_button_label, "Ignore error & continue");
            } else {
                lv_obj_add_flag(form_error_container, LV_OBJ_FLAG_HIDDEN);
                lv_obj_set_style_bg_color(continue_button_button, lv_color_hex(0x007A3D), LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_label_set_text(continue_button_label, "Success! Press to Continue");
            }

            // Selection handling
            // Selection handling
            if (screen_state.selection == "BLE") {
                lv_obj_clear_flag(form_testing_area_ble, LV_OBJ_FLAG_HIDDEN);
                lv_obj_add_flag(form_testing_area_manual, LV_OBJ_FLAG_HIDDEN);

                // Highlight BLE button
                lv_obj_set_style_bg_color(form_button_ble_button, lv_color_hex(0x0000FF), LV_PART_MAIN | LV_STATE_DEFAULT);  // Blue
                lv_obj_set_style_bg_color(form_button_manual_button, lv_color_hex(0x313131), LV_PART_MAIN | LV_STATE_DEFAULT); // Grey

                if (screen_state.ble_busy) {
                    lv_label_set_text(try_again_button_label, "Trying...");
                    lv_obj_add_state(try_again_button_button, LV_STATE_DISABLED);
                } else {
                    lv_label_set_text(try_again_button_label, "Try again...");
                    lv_obj_clear_state(try_again_button_button, LV_STATE_DISABLED);
                }
            }
            if (screen_state.selection == "Manual") {
                lv_obj_add_flag(form_testing_area_ble, LV_OBJ_FLAG_HIDDEN);
                lv_obj_clear_flag(form_testing_area_manual, LV_OBJ_FLAG_HIDDEN);

                // Highlight Manual button
                lv_obj_set_style_bg_color(form_button_manual_button, lv_color_hex(0x0000FF), LV_PART_MAIN | LV_STATE_DEFAULT);  // Blue
                lv_obj_set_style_bg_color(form_button_ble_button, lv_color_hex(0x313131), LV_PART_MAIN | LV_STATE_DEFAULT); // Grey
            }

        }
        state_changed = false;
    }
}

int BIOS::unmount() {
    delete mail_time_service;
    return 0;
}

virtus\Apps\System\BIOS\BIOS.h-------------------------------------------------
#ifndef BIOS_H
#define BIOS_H

#include "Apps/BaseApp.h"
#include "Services/Mailbox/Mailbox.h"

class BIOS : public BaseApp {
public:
    virtual int mount(lv_obj_t* canvas);
    virtual int unmount();
    virtual void update_live_state();

    void setup_system_comm(Mailbox<int>* mailbox);

private:
    static Mailbox<int>* system_mailbox;

    struct SCREEN_STATE {
        bool splash = true;

        bool error = true;
        String selection = "BLE"; // 'BLE' or 'Manual' for now
            
        bool ble_busy = false;

    } screen_state;
    bool state_changed;
    Mailbox<int>* mail_time_service;

    static void ble_button_clicked(lv_event_t * e);
    static void manual_button_clicked(lv_event_t * e);
    static void ble_try_again_button_clicked(lv_event_t * e);
    static void continue_button_clicked(lv_event_t * e);
    
    lv_obj_t* frame;
    lv_obj_t* splash_container;
    lv_obj_t* splash_label;
    lv_obj_t* form_title_container;
    lv_obj_t* form_title_label;
    lv_obj_t* form_subtitle_container;
    lv_obj_t* form_subtitle_label;
    lv_obj_t* form_error_container;
    lv_obj_t* form_error_label;
    lv_obj_t* form_button_ble_container;
    lv_obj_t* form_button_ble_button;
    lv_obj_t* form_button_ble_button_label;
    lv_obj_t* form_button_manual_container;
    lv_obj_t* form_button_manual_button;
    lv_obj_t* form_button_manual_label;
    lv_obj_t* form_testing_area;
    lv_obj_t* form_testing_area_ble;
    lv_obj_t* ble_info_container;
    lv_obj_t* ble_info_label;
    lv_obj_t* try_again_button_container;
    lv_obj_t* try_again_button_button;
    lv_obj_t* try_again_button_label;
    lv_obj_t* form_testing_area_manual;
    lv_obj_t* manual_info_label;
    lv_obj_t* continue_button_container;
    lv_obj_t* continue_button_button;
    lv_obj_t* continue_button_label;
};

extern BIOS bios;

#endif

virtus\Apps\System\DefaultWatchFace\DefaultWatchFace.cpp-------------------------------------------------
#include "Apps/System/DefaultWatchFace/DefaultWatchFace.h"
#include "Services/TimeService/TimeService.h"

#include <lvgl.h>

DefaultWatchFace default_watch_face;

int DefaultWatchFace::mount(lv_obj_t* canvas) {

    frame = lv_obj_create(canvas);
    lv_obj_remove_style_all(frame);
    lv_obj_set_width(frame, lv_pct(100));
    lv_obj_set_height(frame, lv_pct(100));
    lv_obj_set_pos(frame, 0, 0);
    lv_obj_set_align(frame, LV_ALIGN_TOP_LEFT);
    lv_obj_clear_flag(frame, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN);     /// Flags
    lv_obj_set_style_bg_color(frame, lv_color_hex(0x000000), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(frame, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    full_time_container = lv_obj_create(frame);
    lv_obj_remove_style_all(full_time_container);
    lv_obj_set_width(full_time_container, lv_pct(100));
    lv_obj_set_height(full_time_container, lv_pct(30));
    lv_obj_set_x(full_time_container, 0);
    lv_obj_set_y(full_time_container, lv_pct(-10));
    lv_obj_set_align(full_time_container, LV_ALIGN_CENTER);
    lv_obj_set_flex_flow(full_time_container, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(full_time_container, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_END, LV_FLEX_ALIGN_START);
    lv_obj_clear_flag(full_time_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);      /// Flags

    hh_mm_label = lv_label_create(full_time_container);
    lv_obj_set_x(hh_mm_label, -30);
    lv_obj_set_y(hh_mm_label, 0);
    lv_obj_set_align(hh_mm_label, LV_ALIGN_CENTER);
    lv_label_set_text(hh_mm_label, "44:48");
    lv_obj_set_style_text_color(hh_mm_label, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(hh_mm_label, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(hh_mm_label, &lv_font_montserrat_48, LV_PART_MAIN | LV_STATE_DEFAULT);

    am_pm_label = lv_label_create(full_time_container);
    lv_obj_set_x(am_pm_label, -30);
    lv_obj_set_y(am_pm_label, 0);
    lv_obj_set_align(am_pm_label, LV_ALIGN_CENTER);
    lv_label_set_text(am_pm_label, "PM");
    lv_obj_set_style_text_color(am_pm_label, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(am_pm_label, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(am_pm_label, &lv_font_montserrat_36, LV_PART_MAIN | LV_STATE_DEFAULT);

    day_date_container = lv_obj_create(frame);
    lv_obj_remove_style_all(day_date_container);
    lv_obj_set_width(day_date_container, lv_pct(100));
    lv_obj_set_height(day_date_container, lv_pct(30));
    lv_obj_set_x(day_date_container, lv_pct(0));
    lv_obj_set_y(day_date_container, lv_pct(20));
    lv_obj_set_align(day_date_container, LV_ALIGN_CENTER);
    lv_obj_set_flex_flow(day_date_container, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(day_date_container, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_clear_flag(day_date_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);      /// Flags

    day_label = lv_label_create(day_date_container);
    lv_obj_set_x(day_label, 8);
    lv_obj_set_y(day_label, -1);
    lv_obj_set_align(day_label, LV_ALIGN_TOP_RIGHT);
    lv_label_set_text(day_label, "Monday");
    lv_obj_set_style_text_color(day_label, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(day_label, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(day_label, &lv_font_montserrat_20, LV_PART_MAIN | LV_STATE_DEFAULT);

    date_label = lv_label_create(day_date_container);
    lv_obj_set_x(date_label, 8);
    lv_obj_set_y(date_label, -1);
    lv_obj_set_align(date_label, LV_ALIGN_TOP_RIGHT);
    lv_label_set_text(date_label, "11.11.11");
    lv_obj_set_style_text_color(date_label, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(date_label, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(date_label, &lv_font_montserrat_20, LV_PART_MAIN | LV_STATE_DEFAULT);

    return 0;
}

void DefaultWatchFace::update_live_state() {
    struct tm time_info = time_service.get_time(true);

    // Format HH:MM (12-hour format, no zero padding)
    char hhmm[12];
    int display_hour = time_info.tm_hour % 12;
    if (display_hour == 0) display_hour = 12;  // handle midnight/noon
    snprintf(hhmm, sizeof(hhmm), "%d:%d", display_hour, time_info.tm_min);
    lv_label_set_text(hh_mm_label, hhmm);

    // Set AM/PM
    lv_label_set_text(am_pm_label, (time_info.tm_hour >= 12) ? "PM" : "AM");

    // Set Day (e.g., Monday)
    const char* day_names[] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
    lv_label_set_text(day_label, day_names[time_info.tm_wday]);

    // Format and set date (e.g., 4.11.25) as month.day.year (no padding)
    char date[16];
    snprintf(date, sizeof(date), "%d.%d.%d", time_info.tm_mon + 1, time_info.tm_mday, (time_info.tm_year + 1900) % 100);
    lv_label_set_text(date_label, date);
}

int DefaultWatchFace::unmount() {
    return 0;
}

virtus\Apps\System\DefaultWatchFace\DefaultWatchFace.h-------------------------------------------------
#ifndef DEFAULTWATCHFACE_H
#define DEFAULTWATCHFACE_H

#include "Apps/BaseApp.h"

class DefaultWatchFace : public BaseApp {
public:
    virtual int mount(lv_obj_t* canvas);
    virtual int unmount();
    virtual void update_live_state();

private:
    lv_obj_t* frame;
    lv_obj_t* full_time_container;
    lv_obj_t* hh_mm_label;
    lv_obj_t* am_pm_label;
    lv_obj_t* day_date_container;
    lv_obj_t* day_label;
    lv_obj_t* date_label;
};

extern DefaultWatchFace default_watch_face;

#endif

virtus\Drivers\BaseDriver.h-------------------------------------------------
#ifndef BASEDRIVER_H
#define BASEDRIVER_H

#include "utilities.h"

class  BaseDriver {
public:
protected:
    virtual int handle_basic_boot() { return 0; }
    virtual int handle_first_time_boot() { return 0; }
    virtual int handle_os_init() { return 0; }
    virtual int handle_active_loop() { return 0; }

};

#endif

virtus\Drivers\Battery\Battery.cpp-------------------------------------------------
#include "Battery.h"

Battery battery;

int Battery::handle_basic_boot() {

    bool res =  XPowersAXP2101::init(Wire, BOARD_I2C_SDA, BOARD_I2C_SCL);
    if (!res) {
        return 1;
    }

    // Set the minimum common working voltage of the PMU VBUS input,
    // below this value will turn off the PMU
    setVbusVoltageLimit(XPOWERS_AXP2101_VBUS_VOL_LIM_4V36);

    // Set the maximum current of the PMU VBUS input,
    // higher than this value will turn off the PMU
    setVbusCurrentLimit(XPOWERS_AXP2101_VBUS_CUR_LIM_900MA);

    // Set VSY off voltage as 2600mV , Adjustment range 2600mV ~ 3300mV
    setSysPowerDownVoltage(2600);


    // ! ESP32S3 VDD, Don't change
    // setDC1Voltage(3300);

    //! RTC VBAT , Don't change
    setALDO1Voltage(3300);

    //! TFT BACKLIGHT VDD , Don't change
    setALDO2Voltage(3300);

    //!Screen touch VDD , Don't change
    setALDO3Voltage(3300);

    //! Radio VDD , Don't change
    setALDO4Voltage(3300);

    //!DRV2605 enable
    setBLDO2Voltage(3300);

    //! GPS Power
    setDC3Voltage(3300);
    enableDC3();

    //! No use
    disableDC2();
    // disableDC3();
    disableDC4();
    disableDC5();
    disableBLDO1();
    disableCPUSLDO();
    disableDLDO1();
    disableDLDO2();



    enableALDO1();  //! RTC VBAT
    enableALDO2();  //! TFT BACKLIGHT   VDD
    enableALDO3();  //! Screen touch VDD
    enableALDO4();  //! Radio VDD
    enableBLDO2();  //! drv2605 enable


    // if (stream) {
    //     log_println("DCDC=======================================================================");
    //     stream->printf("DC1  : %s   Voltage:%u mV \n", isEnableDC1()  ? "+" : "-", getDC1Voltage());
    //     stream->printf("DC2  : %s   Voltage:%u mV \n", isEnableDC2()  ? "+" : "-", getDC2Voltage());
    //     stream->printf("DC3  : %s   Voltage:%u mV \n", isEnableDC3()  ? "+" : "-", getDC3Voltage());
    //     stream->printf("DC4  : %s   Voltage:%u mV \n", isEnableDC4()  ? "+" : "-", getDC4Voltage());
    //     stream->printf("DC5  : %s   Voltage:%u mV \n", isEnableDC5()  ? "+" : "-", getDC5Voltage());
    //     log_println("ALDO=======================================================================");
    //     stream->printf("ALDO1: %s   Voltage:%u mV\n", isEnableALDO1()  ? "+" : "-", getALDO1Voltage());
    //     stream->printf("ALDO2: %s   Voltage:%u mV\n", isEnableALDO2()  ? "+" : "-", getALDO2Voltage());
    //     stream->printf("ALDO3: %s   Voltage:%u mV\n", isEnableALDO3()  ? "+" : "-", getALDO3Voltage());
    //     stream->printf("ALDO4: %s   Voltage:%u mV\n", isEnableALDO4()  ? "+" : "-", getALDO4Voltage());
    //     log_println("BLDO=======================================================================");
    //     stream->printf("BLDO1: %s   Voltage:%u mV\n", isEnableBLDO1()  ? "+" : "-", getBLDO1Voltage());
    //     stream->printf("BLDO2: %s   Voltage:%u mV\n", isEnableBLDO2()  ? "+" : "-", getBLDO2Voltage());
    //     log_println("CPUSLDO====================================================================");
    //     stream->printf("CPUSLDO: %s Voltage:%u mV\n", isEnableCPUSLDO() ? "+" : "-", getCPUSLDOVoltage());
    //     log_println("DLDO=======================================================================");
    //     stream->printf("DLDO1: %s   Voltage:%u mV\n", isEnableDLDO1()  ? "+" : "-", getDLDO1Voltage());
    //     stream->printf("DLDO2: %s   Voltage:%u mV\n", isEnableDLDO2()  ? "+" : "-", getDLDO2Voltage());
    //     log_println("===========================================================================");
    // }


    // Set the time of pressing the button to turn off
    setPowerKeyPressOffTime(XPOWERS_POWEROFF_4S);

    // Set the button power-on press time
    setPowerKeyPressOnTime(XPOWERS_POWERON_128MS);


    // It is necessary to disable the detection function of the TS pin on the board
    // without the battery temperature detection function, otherwise it will cause abnormal charging
    disableTSPinMeasure();


    // Enable internal ADC detection
    enableBattDetection();
    enableVbusVoltageMeasure();
    enableBattVoltageMeasure();
    enableSystemVoltageMeasure();


    //t-watch no chg led
    setChargingLedMode(XPOWERS_CHG_LED_OFF);


    disableIRQ(XPOWERS_AXP2101_ALL_IRQ);

    /*
    Battery insert/remove.
    USB plug/unplug.
    Short/long power button press.
    Charging start/done.
    These pull BOARD_PMU_INT low when triggered.
    */

    // Enable the required interrupt function
    enableIRQ(
        XPOWERS_AXP2101_BAT_INSERT_IRQ    | XPOWERS_AXP2101_BAT_REMOVE_IRQ      |   //BATTERY
        XPOWERS_AXP2101_VBUS_INSERT_IRQ   | XPOWERS_AXP2101_VBUS_REMOVE_IRQ     |   //VBUS
        XPOWERS_AXP2101_PKEY_SHORT_IRQ    | XPOWERS_AXP2101_PKEY_LONG_IRQ       |   //POWER KEY
        XPOWERS_AXP2101_BAT_CHG_DONE_IRQ  | XPOWERS_AXP2101_BAT_CHG_START_IRQ       //CHARGE
    );

    // Clear all interrupt flags
    XPowersAXP2101::clearIrqStatus();

    // Set the precharge charging current
    setPrechargeCurr(XPOWERS_AXP2101_PRECHARGE_50MA);
    // Set constant current charge current limit
    setChargerConstantCurr(XPOWERS_AXP2101_CHG_CUR_300MA);
    // Set stop charging termination current
    setChargerTerminationCurr(XPOWERS_AXP2101_CHG_ITERM_25MA);

    // Set charge cut-off voltage
    setChargeTargetVoltage(XPOWERS_AXP2101_CHG_VOL_4V35);

    // Set RTC Battery voltage to 3.3V
    setButtonBatteryChargeVoltage(3300);

    enableButtonBatteryCharge();

    return 0;
}

virtus\Drivers\Battery\Battery.h-------------------------------------------------
#ifndef BATTERY_H
#define BATTERY_H

#include "XPowersLib.h"

#include "Drivers/BaseDriver.h"

class Battery : BaseDriver, public XPowersAXP2101 {
    friend class System;
    friend class Screen;
public:
protected:
    virtual int handle_basic_boot() override;
    // virtual int handle_first_time_boot() override;
    // virtual int handle_os_init() override;
    // virtual int handle_active_loop() override;
};

extern Battery battery;

#endif

virtus\Drivers\Screen\Screen.cpp-------------------------------------------------
#include "Screen.h"
#include "Drivers/Screen/LV/LV_Helper.h"

Screen screen;

int Screen::handle_basic_boot() {

#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5,0,0)
    ledcAttach(BOARD_TFT_BL, LEDC_BACKLIGHT_FREQ, LEDC_BACKLIGHT_BIT_WIDTH);
#else
    ledcSetup(LEDC_BACKLIGHT_CHANNEL, LEDC_BACKLIGHT_FREQ, LEDC_BACKLIGHT_BIT_WIDTH);
    ledcAttachPin(BOARD_TFT_BL, LEDC_BACKLIGHT_CHANNEL);
#endif

    TFT_eSPI::init();
    setBrightness(50);
    setRotation(2);
    fillScreen(TFT_BLACK);

    TouchDrvFT6X36::begin(Wire1, FT6X36_SLAVE_ADDRESS, BOARD_TOUCH_SDA, BOARD_TOUCH_SCL);
    interruptTrigger();

    beginLvglHelper(false);
    return 0;
}

void Screen::setBrightness(uint8_t level)
{
    if (!level) {
        battery.disableALDO2();
        writecommand(0x10);  //display sleep
        setPowerMode(PMODE_MONITOR);
    }
    if (!brightness && level != 0) {
        battery.enableALDO2();
        writecommand(0x11);  //display wakeup
    }
    brightness = level;
#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5,0,0)
    ledcWrite(BOARD_TFT_BL, brightness);
#else
    ledcWrite(LEDC_BACKLIGHT_CHANNEL, brightness);
#endif
}

virtus\Drivers\Screen\Screen.h-------------------------------------------------
#ifndef SCREEN_H
#define SCREEN_H

#include <TFT_eSPI.h>
#include <TouchDrvFT6X36.hpp>
#include <lvgl.h>

#include "Drivers/BaseDriver.h"
#include "Drivers/Battery/Battery.h"
#include "utilities.h"

#define LEDC_BACKLIGHT_CHANNEL      3
#define LEDC_BACKLIGHT_BIT_WIDTH    8
#define LEDC_BACKLIGHT_FREQ         1000

class Screen : BaseDriver, public TFT_eSPI, public TouchDrvFT6X36 {
    friend class System;

public:
    void begin_lvgl(bool debug = false);
    void update_lvgl();

protected:
    virtual int handle_basic_boot() override;
    void setBrightness(uint8_t level);

    uint8_t brightness;

private:
    static void disp_flush(lv_disp_drv_t* disp, const lv_area_t* area, lv_color_t* color_p);
    static void touchpad_read(lv_indev_drv_t* indev_driver, lv_indev_data_t* data);

    static Screen* instance;
    static lv_disp_drv_t disp_drv;
    static lv_indev_drv_t indev_drv;
    static lv_disp_draw_buf_t draw_buf;

#ifdef BOARD_HAS_PSRAM
    static lv_color_t* buf;
    static lv_color_t* buf1;
#else
    static lv_color_t buf[];
    static lv_color_t buf1[];
#endif
};

extern Screen screen;

#endif


virtus\Drivers\Screen\LV\LV_Helper.cpp-------------------------------------------------
/**
 * @file      LV_Helper.cpp
 * @author    Lewis He (lewishe@outlook.com)
 * @license   MIT
 * @copyright Copyright (c) 2023  Shenzhen Xinyuan Electronic Technology Co., Ltd
 * @date      2023-04-28
 *
 */

#include "Drivers/Screen/Screen.h"
#include <lvgl.h>

#include "EasySerial.h"

static lv_disp_drv_t disp_drv;
static lv_indev_drv_t  indev_drv;
static lv_disp_draw_buf_t draw_buf;

void updateLvglHelper()
{
    lv_disp_drv_update(lv_disp_get_default(), &disp_drv);
}


/* Display flushing */
#if LV_VERSION_CHECK(9,0,0)
void disp_flush( lv_disp_t *disp, const lv_area_t *area, lv_color_t *color_p )
#else
void disp_flush( lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p )
#endif
{
    uint32_t w = ( area->x2 - area->x1 + 1 );
    uint32_t h = ( area->y2 - area->y1 + 1 );

    screen.startWrite();
    screen.setAddrWindow( area->x1, area->y1, w, h );

#if LV_VERSION_CHECK(9,0,0)
    // int32_t x;
    // int32_t y;
    // for (y = area->y1; y <= area->y2; y++) {
    //     for (x = area->x1; x <= area->x2; x++) {
    //         screen.drawPixel(x, y, *(uint16_t *)(color_p));
    //         color_p++;
    //     }
    // }
    screen.pushColors(( uint16_t * )color_p, w * h);
#else
    screen.pushColors(( uint16_t * )&color_p->full, w * h, true );
#endif
    screen.endWrite();

    lv_disp_flush_ready( disp );
}

/*Read the touchpad*/
#if LV_VERSION_CHECK(9,0,0)
void touchpad_read( lv_indev_t *indev_driver, lv_indev_data_t *data )
#else
void touchpad_read( lv_indev_drv_t *indev_driver, lv_indev_data_t *data )
#endif
{
    int16_t x, y;
    bool touched = screen.getPoint(&x, &y);
    if ( !touched ) {
        data->state = LV_INDEV_STATE_REL;
    } else {
        switch (screen.getRotation()) {
        case 0:
            data->point.x = TFT_WIDTH - x;
            data->point.y = TFT_HEIGHT - y;
            break;
        case 1:
            data->point.x = TFT_WIDTH - y;
            data->point.y =  x;
            break;
        case 3:
            data->point.x = y;
            data->point.y = TFT_HEIGHT - x;
            break;
        case 2:
        default:
            data->point.x = x;
            data->point.y = y;
        }
        // es.println("Touch detected - X:" + String(data->point.x) + " Y:" + String(data->point.y));
        data->state = LV_INDEV_STATE_PR;
    }
}

#ifndef BOARD_HAS_PSRAM
static const size_t lv_buffer_size = (BOARD_TFT_WIDTH * 50);
static lv_color_t buf[ lv_buffer_size ];
static lv_color_t buf1[ lv_buffer_size ];
#else
static const size_t lv_buffer_size = BOARD_TFT_WIDTH * BOARD_TFT_HEIGHT * sizeof(lv_color_t);
static lv_color_t *buf  = NULL;
static lv_color_t *buf1  = NULL;
#endif

#if LV_USE_LOG
#if LV_VERSION_CHECK(9,0,0)
void lv_log_print_g_cb(lv_log_level_t level, const char *buf)
#else
void lv_log_print_g_cb(const char *buf)
#endif
{
    Serial.println(buf);
    Serial.flush();
}
#endif //LV_USE_LOG

void beginLvglHelper(bool debug)
{
    lv_init();

#if LV_USE_LOG
    if (debug) {
        lv_log_register_print_cb(lv_log_print_g_cb);
    }
#endif //LV_USE_LOG

#ifdef BOARD_HAS_PSRAM
    buf = (lv_color_t *)ps_malloc(lv_buffer_size);
    if (!buf) {
        while (1) {
            delay(1000);
            Serial.println("Memory buffer failed!");
        }
    }
    buf1 = (lv_color_t *)ps_malloc(lv_buffer_size);
    if (!buf1) {
        while (1) {
            delay(1000);
            Serial.println("Memory buffer failed!");
        }
    }
#endif //BOARD_HAS_PSRAM

#if LV_VERSION_CHECK(9,0,0)
    lv_disp_t *disp =  lv_disp_create(BOARD_TFT_WIDTH, BOARD_TFT_HEIGHT);

#ifdef BOARD_HAS_PSRAM
    lv_disp_set_draw_buffers(disp, buf, buf1, BOARD_TFT_WIDTH * BOARD_TFT_HEIGHT, LV_DISP_RENDER_MODE_PARTIAL);
#else
    lv_disp_set_draw_buffers(disp, buf, NULL, sizeof(buf), LV_DISP_RENDER_MODE_PARTIAL);
#endif
    // lv_disp_set_driver_data()/
    lv_disp_set_res(disp, BOARD_TFT_WIDTH, BOARD_TFT_HEIGHT);
    lv_disp_set_physical_res(disp, BOARD_TFT_WIDTH, BOARD_TFT_HEIGHT);
    lv_disp_set_flush_cb(disp, disp_flush);

    lv_indev_t *indev = lv_indev_create();
    lv_indev_set_read_cb(indev, touchpad_read);
    lv_indev_set_disp(indev, disp);
    lv_indev_set_type(indev, LV_INDEV_TYPE_POINTER);
    // lv_indev_set_driver_data();

#else

#ifdef BOARD_HAS_PSRAM
    lv_disp_draw_buf_init( &draw_buf, buf, buf1, lv_buffer_size);
#else
    lv_disp_draw_buf_init( &draw_buf, buf, buf1, lv_buffer_size );
#endif

    /*Initialize the display*/
    lv_disp_drv_init( &disp_drv );
    /*Change the following line to your display resolution*/
    disp_drv.hor_res = BOARD_TFT_WIDTH;
    disp_drv.ver_res = BOARD_TFT_HEIGHT;
    disp_drv.flush_cb = disp_flush;
    disp_drv.draw_buf = &draw_buf;

    lv_disp_drv_register( &disp_drv );

    /*Initialize the input device driver*/
    lv_indev_drv_init( &indev_drv );
    indev_drv.type = LV_INDEV_TYPE_POINTER;
    indev_drv.read_cb = touchpad_read;
    lv_indev_drv_register( &indev_drv );

#endif
}

virtus\Drivers\Screen\LV\LV_Helper.h-------------------------------------------------
/**
 * @file      LV_Helper.h
 * @author    Lewis He (lewishe@outlook.com)
 * @license   MIT
 * @copyright Copyright (c) 2023  Shenzhen Xinyuan Electronic Technology Co., Ltd
 * @date      2023-04-28
 *
 */

#pragma once

void beginLvglHelper(bool debug = false);
void updateLvglHelper();


virtus\Services\BaseService.h-------------------------------------------------
#ifndef BASESERVICE_H
#define BASESERVICE_H

#include <Arduino.h>

#include "utilities.h"

class BaseService {
public:
    virtual ~BaseService() {};
protected:
    virtual int handle_basic_boot() { return 0; }
    virtual int handle_first_time_boot() { return 0; }
    virtual int handle_os_init() { return 0; }
    virtual int handle_active_loop() { return 0; }
};

#endif

virtus\Services\BTServer\BTServer.cpp-------------------------------------------------
#include "BTServer.h"
#include "esp_gatt_common_api.h"
#include "EasySerial.h"

BTServer bt_server;

int BTServer::start_server(const ServerConfig& config) {
    if (xSemaphoreTake(lock_handle, 10) != pdTRUE) return -1;
    
    if (!config.service_uuid || config.characteristics.empty()) {
        xSemaphoreGive(lock_handle);
        return -2;
    }

    clear_state();
    BLEDevice::init("BTServer");
    esp_ble_gatt_set_local_mtu(100);

    server = BLEDevice::createServer();
    if (!server) {
        xSemaphoreGive(lock_handle);
        return -2;
    }

    class InternalCallbacks : public BLEServerCallbacks {
    public:
        InternalCallbacks(BLEServer* serverPtr,
                            std::function<void()> onC,
                            std::function<void()> onD)
            : _server(serverPtr), _onConnect(onC), _onDisconnect(onD) {}
    
        void onConnect(BLEServer* pServer) override {
            es.println("Connected! MTU: " + String(_server->getPeerMTU(_server->getConnId())));
            if (_onConnect) _onConnect();
        }
    
        void onDisconnect(BLEServer* pServer) override {
            if (_onDisconnect) _onDisconnect();
        }
    
    private:
        BLEServer* _server;
        std::function<void()> _onConnect;
        std::function<void()> _onDisconnect;
    };
        

    server->setCallbacks(new InternalCallbacks(server, config.onConnect, config.onDisconnect));
    service = server->createService(config.service_uuid);
    if (!service) {
        clear_state();
        xSemaphoreGive(lock_handle);
        return -2;
    }

    for (const auto& c : config.characteristics) {
        if (!c.uuid || !c.flags || strlen(c.uuid) < 4) {
            clear_state();
            xSemaphoreGive(lock_handle);
            return -2;
        }

        es.println("---- Characteristic Setup ----");
        es.println("UUID  : " + String(c.uuid));
        es.println("Flags : " + String(c.flags));

        uint32_t props = 0;
        // Check and apply flags
        if (strchr(c.flags, 'R')) {
            props |= BLECharacteristic::PROPERTY_READ;
            es.println("  Adding PROPERTY_READ");
        }
        if (strchr(c.flags, 'W')) {
            props |= BLECharacteristic::PROPERTY_WRITE;
            es.println("  Adding PROPERTY_WRITE");
        }
        if (strchr(c.flags, 'N')) {
            props |= BLECharacteristic::PROPERTY_NOTIFY;
            es.println("  Adding PROPERTY_NOTIFY");
        }

        char buf[32];
        sprintf(buf, "Final props bitmask: 0x%X", props);
        es.println(String(buf));

        es.println("-----------------------------");

        BLECharacteristic* ch = service->createCharacteristic(c.uuid, props);
        if (!ch) {
            clear_state();
            xSemaphoreGive(lock_handle);
            return -2;
        }

        class CharCallbacks : public BLECharacteristicCallbacks {
        public:
            CharCallbacks(std::function<void()> onW, std::function<void()> onR)
                : _onWrite(onW), _onRead(onR) {}
        
            void onWrite(BLECharacteristic* c) override {
                if (_onWrite) _onWrite();
            }
        
            void onRead(BLECharacteristic* c) override {
                if (_onRead) _onRead();
            }
        
        private:
            std::function<void()> _onWrite;
            std::function<void()> _onRead;
        };
            

        ch->setCallbacks(new CharCallbacks(c.onWrite, c.onRead));
        char_map[c.uuid] = ch;
        notify_flags[c.uuid] = strchr(c.flags, 'N') != nullptr;
    }

    service->start();
    BLEAdvertising* adv = BLEDevice::getAdvertising();
    adv->addServiceUUID(config.service_uuid);
    adv->start();

    return 0;  // Success, lock remains taken
}

void BTServer::kill_server() {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }

    if (server && server->getConnectedCount() > 0) {
        server->disconnect(0);  // Disconnect first connected client (handle 0)
    }

    BLEAdvertising* adv = BLEDevice::getAdvertising();
    if (adv) adv->stop();  // Stop advertising to prevent new connections
    
    clear_state();
    xSemaphoreGive(lock_handle);
}

void BTServer::clear_state() {
    if (service) {
        service->stop();
        server->removeService(service);
        service = nullptr;
    }
    if (server) {
        delete server;
        server = nullptr;
    }
    char_map.clear();
    notify_flags.clear();
}

// Setters (no notify)
void BTServer::set(const std::string& uuid, const std::string& value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid)) char_map[uuid]->setValue(value);
}

void BTServer::set(const std::string& uuid, uint16_t value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid)) char_map[uuid]->setValue(value);
}

void BTServer::set(const std::string& uuid, uint32_t value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid)) char_map[uuid]->setValue(value);
}

void BTServer::set(const std::string& uuid, int value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid)) char_map[uuid]->setValue(value);
}

void BTServer::set(const std::string& uuid, float value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid)) char_map[uuid]->setValue(value);
}

void BTServer::set(const std::string& uuid, double value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid)) char_map[uuid]->setValue(value);
}

// Notify (set + notify if allowed)
void BTServer::notify(const std::string& uuid, const std::string& value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid) && notify_flags[uuid]) {
        char_map[uuid]->setValue(value);
        char_map[uuid]->notify();
    }
}

void BTServer::notify(const std::string& uuid, uint16_t value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid) && notify_flags[uuid]) {
        char_map[uuid]->setValue(value);
        char_map[uuid]->notify();
    }
}

void BTServer::notify(const std::string& uuid, uint32_t value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid) && notify_flags[uuid]) {
        char_map[uuid]->setValue(value);
        char_map[uuid]->notify();
    }
}

void BTServer::notify(const std::string& uuid, int value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid) && notify_flags[uuid]) {
        char_map[uuid]->setValue(value);
        char_map[uuid]->notify();
    }
}

void BTServer::notify(const std::string& uuid, float value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid) && notify_flags[uuid]) {
        char_map[uuid]->setValue(value);
        char_map[uuid]->notify();
    }
}

void BTServer::notify(const std::string& uuid, double value) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return;
    }
    if (char_map.count(uuid) && notify_flags[uuid]) {
        char_map[uuid]->setValue(value);
        char_map[uuid]->notify();
    }
}

bool BTServer::can_notify(const std::string& uuid) {
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return false;
    }
    return notify_flags.count(uuid) && notify_flags[uuid];
}

template<>
String BTServer::peek<String>(const String& uuid) {
    String result;
    std::string uuid_str = uuid.c_str();
    if (xSemaphoreTake(lock_handle, 0) == pdTRUE) {
        xSemaphoreGive(lock_handle);
        return result;  // Empty string if server not running
    }
    if (char_map.count(uuid_str)) {
        BLECharacteristic* ch = char_map[uuid_str];
        size_t len = ch->getLength();
        const uint8_t* raw = ch->getData();
        if (len > 0) {
            result = String(reinterpret_cast<const char*>(raw));
        }
    }
    return result;
}

virtus\Services\BTServer\BTServer.h-------------------------------------------------
#ifndef BTSERVER_H
#define BTSERVER_H

#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <map>
#include <vector>
#include <string.h>
#include <string>
#include <WString.h>
#include "Services/BaseService.h"
#include "EasySerial.h"
#include "freertos/FreeRTOS.h"      // Add FreeRTOS header
#include "freertos/semphr.h"        // Add semaphore header
#include <functional>

struct CharacteristicConfig {
    const char* uuid;
    const char* flags;
    std::function<void()> onWrite;
    std::function<void()> onRead;
};

struct ServerConfig {
    const char* service_uuid;
    std::vector<CharacteristicConfig> characteristics;
    std::function<void()> onConnect;
    std::function<void()> onDisconnect;
};

class BTServer : public BaseService {
public:
    BTServer() : server(nullptr), service(nullptr), lock_handle(nullptr) {
        lock_handle = xSemaphoreCreateBinary();  // Create semaphore in constructor
        xSemaphoreGive(lock_handle);            // Initially available
    }
    
    ~BTServer() {
        if (lock_handle) vSemaphoreDelete(lock_handle);  // Cleanup
    }

    int start_server(const ServerConfig& config);
    void kill_server();
    void set(const std::string& uuid, const std::string& value);
    void set(const std::string& uuid, uint16_t value);
    void set(const std::string& uuid, uint32_t value);
    void set(const std::string& uuid, int value);
    void set(const std::string& uuid, float value);
    void set(const std::string& uuid, double value);
    void notify(const std::string& uuid, const std::string& value);
    void notify(const std::string& uuid, uint16_t value);
    void notify(const std::string& uuid, uint32_t value);
    void notify(const std::string& uuid, int value);
    void notify(const std::string& uuid, float value);
    void notify(const std::string& uuid, double value);
    template<typename T> T peek(const String& uuid);
    bool can_notify(const std::string& uuid);

private:
    BLEServer* server;
    BLEService* service;
    std::map<std::string, BLECharacteristic*> char_map;
    std::map<std::string, bool> notify_flags;
    SemaphoreHandle_t lock_handle;  // Changed from bool to semaphore handle

    void clear_state();
};

extern BTServer bt_server;

template<typename T>
T BTServer::peek(const String& uuid) {
    T result{};
    if (uuid.isEmpty() || !uuid.c_str()) {
        es.println("Error: Invalid UUID passed to peek");
        return result;
    }
    std::string uuid_str = uuid.c_str();
    if (char_map.count(uuid_str)) {
        BLECharacteristic* ch = char_map[uuid_str];
        size_t len = ch->getLength();
        const uint8_t* raw = ch->getData();
        if (len > sizeof(T)) {
            es.println("Error: Data too long for " + uuid + ", got " + String(len) + ", max " + String(sizeof(T)));
            return result;
        }
        if (len > 0) {
            memcpy(&result, raw, len);
        } else {
            es.println("Warning: No data for " + uuid);
        }
    } else {
        es.println("Error: UUID not found: " + uuid);
    }
    return result;
}

template<> String BTServer::peek<String>(const String& uuid);

#endif // BTSERVER_H

virtus\Services\Mailbox\Mailbox.h-------------------------------------------------
#ifndef MAILBOX_H
#define MAILBOX_H

#include <freertos/FreeRTOS.h>
#include <freertos/queue.h>

#include "EasySerial.h"

template<typename T>
class Mailbox {
private:
    QueueHandle_t queue;
    static constexpr int default_depth = 10;

public:
    Mailbox() {
        queue = xQueueCreate(default_depth, sizeof(T));
        T dummy;
        while (xQueueReceive(queue, &dummy, 0) == pdTRUE) {} // Drain queue
    }

    ~Mailbox() {
        if (queue) vQueueDelete(queue);
    }

    bool write(const T& item) {
        return xQueueSend(queue, &item, 0) == pdTRUE;
    }

    bool read(T& out, int wait_time_ms = 0) {

        if (!queue) {
            es.println("read on uniitialized");
            return false;
        }
        TickType_t wait_ticks = (wait_time_ms > 0) ? pdMS_TO_TICKS(wait_time_ms) : 0;
        return xQueueReceive(queue, &out, wait_ticks) == pdTRUE;
    }

    Mailbox(const Mailbox&) = delete;
    Mailbox& operator=(const Mailbox&) = delete;
};

#endif

virtus\Services\ScreenManager\ScreenManager.cpp-------------------------------------------------
#include "Services/ScreenManager/ScreenManager.h"
#include "Services/TimeService/TimeService.h"
#include "Drivers/Battery/Battery.h"

#include <lvgl.h>
#include "Apps/AppRegistry.h"
#include <Arduino.h>

#include "EasySerial.h"

ScreenManager screen_manager;

int ScreenManager::handle_basic_boot(bool first_time_boot_complete) {
    if (!first_time_boot_complete) {

        state = BASIC_BOOT;

        lv_obj_t* scr = lv_scr_act();      // Get the active screen
        lv_obj_clean(scr);                // Clear any default content

        // Set black background
        lv_obj_set_style_bg_color(scr, lv_color_black(), 0);
        lv_obj_set_style_bg_opa(scr, LV_OPA_COVER, 0);

        // Create centered label
        lv_obj_t* label = lv_label_create(scr);
        lv_label_set_text(label, "Virtus OS");
        lv_obj_set_style_text_font(label, &lv_font_montserrat_28, 0);  // Larger font
        lv_obj_set_style_text_color(label, lv_palette_main(LV_PALETTE_GREEN), 0);  // Green
        lv_obj_center(label);

        // Flush to display
        lv_task_handler();
        delay(2000);
        return 0;
    }
    return 0;
}

int ScreenManager::mount_app(int id) {
    state = APP;

    es.println("screen manager asked to mount ");

    if (current_app != -1) {
        app_registry[current_app]->unmount();
    }

    es.println(id);

    full_screen = lv_obj_create(NULL);
    lv_obj_clear_flag(full_screen, LV_OBJ_FLAG_SCROLLABLE);      /// Flags

    tob_bar_container = lv_obj_create(full_screen);
    lv_obj_remove_style_all(tob_bar_container);
    lv_obj_set_width(tob_bar_container, lv_pct(100));
    lv_obj_set_height(tob_bar_container, lv_pct(100));
    lv_obj_set_align(tob_bar_container, LV_ALIGN_CENTER);
    lv_obj_set_flex_flow(tob_bar_container, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(tob_bar_container, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
    lv_obj_clear_flag(tob_bar_container, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE |
                      LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN);     /// Flags

    top_bar = lv_obj_create(tob_bar_container);
    lv_obj_set_width(top_bar, lv_pct(100));
    lv_obj_set_height(top_bar, lv_pct(10));
    lv_obj_set_align(top_bar, LV_ALIGN_TOP_MID);
    lv_obj_clear_flag(top_bar, LV_OBJ_FLAG_SCROLLABLE);      /// Flags
    lv_obj_set_style_radius(top_bar, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(top_bar, lv_color_hex(0x424242), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(top_bar, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_side(top_bar, LV_BORDER_SIDE_NONE, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(top_bar, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(top_bar, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(top_bar, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(top_bar, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_row(top_bar, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_column(top_bar, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    time_label = lv_label_create(top_bar);
    lv_obj_set_width(time_label, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(time_label, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_align(time_label, LV_ALIGN_LEFT_MID);
    lv_obj_set_style_text_color(time_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(time_label, &lv_font_montserrat_18, LV_PART_MAIN | LV_STATE_DEFAULT);  // Set larger font

    battery_label = lv_label_create(top_bar);
    lv_obj_set_width(battery_label, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(battery_label, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_align(battery_label, LV_ALIGN_RIGHT_MID);
    lv_obj_set_style_text_color(battery_label, lv_color_white(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(battery_label, &lv_font_montserrat_18, LV_PART_MAIN | LV_STATE_DEFAULT);  // Set larger font

    app_frame = lv_obj_create(tob_bar_container);
    lv_obj_remove_style_all(app_frame);
    lv_obj_set_width(app_frame, lv_pct(100));
    lv_obj_set_height(app_frame, lv_pct(90));
    lv_obj_set_align(app_frame, LV_ALIGN_CENTER);
    lv_obj_clear_flag(app_frame, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE);      /// Flags
    lv_obj_set_pos(app_frame, 0, lv_pct(10));

    // Pass the content frame to the app for rendering
    app_registry[id]->mount(app_frame);

    lv_scr_load(full_screen);

    // Set the current app
    current_app = id;

    return 0;
}

void ScreenManager::update_live_state() {
    // Update time
    struct tm time_info = time_service.get_time(true);
    char time_str[6];
    snprintf(time_str, sizeof(time_str), "%02d:%02d", time_info.tm_hour, time_info.tm_min);
    lv_label_set_text(this->time_label, time_str);

    // Update battery
    int battery_percent = battery.getBatteryPercent();
    bool is_vbus_in = battery.isVbusIn();
    char battery_str[7];
    snprintf(battery_str, sizeof(battery_str), "%s%d%%", is_vbus_in ? "^" : "", battery_percent);
    lv_label_set_text(this->battery_label, battery_str);
}


void ScreenManager::step() {
    lv_disp_trig_activity(NULL);
    lv_task_handler();

    if (state == APP) {
        update_live_state();
        if (current_app != -1) {
            app_registry[current_app]->update_live_state();
        }
    }
}

virtus\Services\ScreenManager\ScreenManager.h-------------------------------------------------
#ifndef SCREENMANAGER_H
#define SCREENMANAGER_H

#include "Drivers/Screen/Screen.h"

typedef enum {
    OFF, // screen not invoked yet
    BASIC_BOOT, // showing the logo on first-time boots or resets
    IDLE, // when there are CPU jobs running but no apps runing
    HOME, // home screen
    APP, // showing a particular app - either during first time boot showing the time sync options or later when showing one app.
} screen_state;

class ScreenManager : public Screen {
    friend class System;
    friend class WorkManager;
public:

protected:
    virtual int handle_basic_boot(bool first_time_boot_complete);
    // virtual int handle_os_init() { return 0; }
    // virtual int handle_active_loop() { return 0; }
    int mount_app(int id);
    void step();
private:
    
    void update_live_state();
    int current_app = -1;
    screen_state state = OFF;

    lv_obj_t* full_screen;
    lv_obj_t* tob_bar_container;
    lv_obj_t* top_bar;
    lv_obj_t* time_label;    // Store time label for live updates
    lv_obj_t* battery_label; // Store battery label for live updates
    lv_obj_t* app_frame;

};

extern ScreenManager screen_manager;

#endif

virtus\Services\TimeService\TimeService.cpp-------------------------------------------------
#include "TimeService.h"
#include "EasySerial.h"

TimeService time_service;

RTC_DATA_ATTR bool time_set_since_cold_boot = false;
RTC_DATA_ATTR int32_t tz_offset;

void TimeService::sync_via_bluetooth(int timeout, Mailbox<int>* mail_time_service) {
    es.println("entering sync via bluetooth");
    ServerConfig config = {
        BT_TIMESERVICE,
        {{ BT_TIMESERVICE_CHAR_RX, "W", [&]() { time_service.bt_on_write_time(); }, nullptr}},
        [&]() { time_service.bt_on_connect(); },
        [&]() { time_service.bt_on_disconnect(); }
    };
    es.println("config made");
    bt_server.start_server(config);

    unsigned long start = millis();
    const unsigned long timeout_ms = timeout * 1000;

    while (true) {
        if (millis() - start > timeout_ms || time_set_since_cold_boot) {
            break;
        }
        delay(10);
    }
    es.println("killing server");
    bt_server.kill_server();

    if (time_set_since_cold_boot){
        es.println("sync successful. continuing");
        mail_time_service->write(0);
    }
    else{
        es.println("sync unsuccessful.");
        mail_time_service->write(1);
    }
}

void TimeService::bt_on_write_time() {
    es.println("written!");

    TimePayload payload = bt_server.peek<TimePayload>(BT_TIMESERVICE_CHAR_RX);

    String datetime = String(payload.year) + "-" +
                  (payload.month < 10 ? "0" : "") + String(payload.month) + "-" +
                  (payload.day < 10 ? "0" : "") + String(payload.day) + " " +
                  (payload.hour < 10 ? "0" : "") + String(payload.hour) + ":" +
                  (payload.minute < 10 ? "0" : "") + String(payload.minute) + ":" +
                  (payload.second < 10 ? "0" : "") + String(payload.second);
    es.println(datetime);

    time_service.setDateTime(payload.year, payload.month, payload.day, payload.hour, payload.minute, payload.second);
    
    tz_offset = payload.tz_offset;

    es.println(payload.tz_offset);
        
    time_set_since_cold_boot = true;
}

void TimeService::bt_on_connect() { 
    es.println("COnnected");

}

void TimeService::bt_on_disconnect() { 
    es.println("Disconnected!");
}

bool TimeService::is_time_set() {   
    return time_set_since_cold_boot;
}

struct tm TimeService::get_time(bool adjust_for_timezone) {
    struct tm result = {0};  // zero initialize

    RTC_DateTime now = getDateTime();
    if (!now.available) {
        return result;  // return zeroed struct if invalid
    }

    // Fill base time (RTC is assumed to be in UTC or local base)
    result.tm_year = now.year - 1900;
    result.tm_mon  = now.month - 1;
    result.tm_mday = now.day;
    result.tm_hour = now.hour;
    result.tm_min  = now.minute;
    result.tm_sec  = now.second;
    result.tm_isdst = 0;

    if (adjust_for_timezone) {
        time_t raw = mktime(&result);
        raw += tz_offset;
        result = *localtime(&raw);  // localtime returns pointer to static
    }

    return result;
}

virtus\Services\TimeService\TimeService.h-------------------------------------------------
#ifndef TIMESERVICE_H
#define TIMESERVICE_H

#include <SensorPCF8563.hpp>
#include <time.h>

#include "Services/BaseService.h"
#include "Services/BTServer/BTServer.h"
#include "Services/Mailbox/Mailbox.h"

#define BT_TIMESERVICE "13371337-0000-4000-8000-133713371337"
#define BT_TIMESERVICE_CHAR_RX "13371337-0001-4000-8000-133713371337"

#pragma pack(push, 1)
struct TimePayload {
    uint16_t year;
    int32_t month;
    int32_t day;
    int32_t hour;
    int32_t minute;
    int32_t second;
    int32_t tz_offset;
};

class TimeService : BaseService, public SensorPCF8563 {
    friend class System;
public:

    void sync_via_bluetooth(int timeout, Mailbox<int>* mail_time_service);
    bool is_time_set();

    void bt_on_connect();
    void bt_on_disconnect();
    void bt_on_write_time();

    struct tm get_time(bool adjust_for_timezone = true);

protected:

};

extern TimeService time_service;

#endif

virtus\Services\WorkManager\WorkManager.cpp-------------------------------------------------
#include "WorkManager.h"
#include "Services/ScreenManager/ScreenManager.h"

WorkManager work_manager;

int WorkManager::add_app_job(int id, time_t time) {

    if (!time) {
        screen_manager.mount_app(id);
        return 0;
    }
    // TODO: Delayed app job scheduling
    return 0;
}

void WorkManager::add_job(TaskHandle_t handle) {
    xSemaphoreTake(job_set_mutex, portMAX_DELAY);
    job_set.insert(handle);
    xSemaphoreGive(job_set_mutex);
}

void WorkManager::remove_job(TaskHandle_t handle) {
    xSemaphoreTake(job_set_mutex, portMAX_DELAY);
    job_set.erase(handle);
    xSemaphoreGive(job_set_mutex);
}

void WorkManager::job_wrapper(void* param) {
    auto* tuple = static_cast<std::tuple<WorkManager*, JobFunc>*>(param);
    WorkManager* self = std::get<0>(*tuple);
    JobFunc func = std::get<1>(*tuple);

    TaskHandle_t handle = xTaskGetCurrentTaskHandle();
    self->add_job(handle);

    func();

    self->remove_job(handle);
    delete tuple;
    vTaskDelete(nullptr);
}


TaskHandle_t WorkManager::add_cpu_job(JobFunc func, time_t time) {
    if (!func) return nullptr;

    if (time == 0) {
        auto* data = new std::tuple<WorkManager*, JobFunc>(this, func);
        TaskHandle_t task_handle = nullptr;
        BaseType_t result = xTaskCreate(
            job_wrapper,
            "cpu_job",
            4096, // Stack size
            data,
            1,    // Priority
            &task_handle
        );
        return (result == pdPASS) ? task_handle : nullptr;
    }

    // TODO: support delayed jobs
    return nullptr;
}


bool WorkManager::cpu_jobs_inactive() {
    xSemaphoreTake(job_set_mutex, portMAX_DELAY);
    bool inactive = job_set.empty();
    xSemaphoreGive(job_set_mutex);
    return inactive;
}


virtus\Services\WorkManager\WorkManager.h-------------------------------------------------
#ifndef WORKMANAGER_H
#define WORKMANAGER_H

#include <functional>
#include <unordered_set>
#include "Time.h" // for time_t
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"

typedef std::function<void()> JobFunc;

class WorkManager {
public:
    int add_app_job(int id, time_t time = 0);
    TaskHandle_t add_cpu_job(JobFunc func, time_t time = 0);

    int step();
    bool cpu_jobs_inactive();

private:
    std::unordered_set<TaskHandle_t> job_set;
    SemaphoreHandle_t job_set_mutex = xSemaphoreCreateMutex();

    void add_job(TaskHandle_t handle);
    void remove_job(TaskHandle_t handle);
    static void job_wrapper(void* param);

};

extern WorkManager work_manager;

#endif // WORKMANAGER_H


